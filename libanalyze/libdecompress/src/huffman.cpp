// The MIT License (MIT)
// Copyright (c) 2023 Eric Froemling
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "huffman.h"

// #include "ballistica/networking/networking.h"

// Yes, I should clean this up to use unsigned vals, but it seems to work
// fine for now so I don't want to touch it.

// how much data we read in training mode before spitting out results
const int kTrainingLength = 200000;

// we currently just have a static table of char frequencies - this can be
// generated by setting "training mode" on.
static int g_freqs[] = {
  101342, 9667, 3497, 1072, 0, 3793, 0, 0, 2815, 5235, 0, 0, 0, 3570, 0, 0,
  0,      1383, 0,    0,    0, 2970, 0, 0, 2857, 0,    0, 0, 0, 0,    0, 0,
  0,      1199, 0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 1494,
  1974,   0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 1351, 0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 1475,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0,
  0,      0,    0,    0,    0, 0,    0, 0, 0,    0,    0, 0, 0, 0,    0, 0
};

Huffman::Huffman() : built(false) {
  static_assert(sizeof(g_freqs) == sizeof(int) * 256);
  build();
}

Huffman::~Huffman() = default;

// void print(std::vector <uint8_t> const &a) {
//    for(int i=0; i < a.size(); i++)
//    std::cout << a.at(i);
//    // std::cout << std::endl;
// }

// hmmm - I saw a crash logged in this function; need to make sure this is
// bulletproof since untrusted data is coming through here..
auto Huffman::decompress(const std::vector<uint8_t>& src)
-> std::vector<uint8_t> {
  auto length = static_cast<uint32_t>(src.size());
  assert(length > 0);

  // for (int i=0; i<src.size(); i++) {
  //   std::cout << (int)src[i] << std::endl;
  // }

  const char* data = (const char*)src.data();

  auto remainder = static_cast<uint8_t>(*data & 0x0F);
  bool compressed = *data >> 7;

  if (compressed) {
    std::vector<uint8_t> out;
    out.reserve(src.size() * 2);  // hopefully minimize reallocations..

    uint32_t bit_length = ((length - 1) * 8);
    if (remainder > bit_length) std::cout << "invalid huffman data" << std::endl;
    bit_length -= remainder;
    uint32_t bit = 0;
    const char* ptr = data + 1;

    // navigate bit by bit through our nodes to build values from binary codes
    while (bit < bit_length) {
      bool bitval = static_cast<bool>((ptr[bit / 8] >> (bit % 8)) & 0x01);
      bit++;

      // 1 in first bit denotes huffman compressed
      if (bitval) {
        int val;
        int n = 510;
        assert(nodes_[n].parent == 0);
        while (true) {
          assert(n <= 510);

          bitval = static_cast<bool>((ptr[bit / 8] >> (bit % 8)) & 0x01);

          // 1 for right, 0 for left
          if (bitval == 0) {
            if (nodes_[n].left_child == -1) {
              val = n;
              break;
            } else {
              n = nodes_[n].left_child;
              bit++;
            }
          } else {
            if (nodes_[n].right_child == -1) {
              val = n;
              break;
            } else {
              n = nodes_[n].right_child;
              bit++;
            }
          }
          // ERICF FIX - if both new children are dead-ends, stop reading
          // bits; otherwise we might read past the end of the buffer.
          // (I assume the original code didn't have child nodes with dual -1s
          // so this case probably never came up)
          if (nodes_[n].left_child == -1 && nodes_[n].right_child == -1) {
            val = n;
            break;
          }

          if (bit > bit_length) {
            std::cout << "huffman decompress got bit > bitlength" << std::endl;
          }
        }
        out.push_back(static_cast<unsigned char&&>(val));
      } else {
        // just read next 8 bits as value
        uint8_t val;
        if (bit % 8 == 0) {
          assert((bit / 8) < (length - 1));
          val = static_cast<uint8_t>(ptr[bit / 8]);
        } else {
          assert((bit / 8 + 1) < (length - 1));
          val = (static_cast<uint8_t>(ptr[bit / 8]) >> bit % 8)
                | (static_cast<uint8_t>(ptr[bit / 8 + 1]) << (8 - bit % 8));
        }
        out.push_back(val);
        bit += 8;
        if (bit > bit_length) {
          std::cout << "huffman decompress got bit > bitlength b (" << bit << " > " << bit_length << ")" << std::endl;
        }
      }
    }
    assert(bit == bit_length);
    // print(out);
    return out;
  } else {
    // uncompressed - just provide it as is
    return src;
  }
}

void Huffman::train(const char* buffer, int len) {
  std::vector<Node> nodes;
  if (built) {
    test_bytes += len;
    for (int i = 0; i < len; i++) {
      test_bits_compressed += nodes[static_cast<uint8_t>(buffer[i])].bits;
    }
    static int poo = 0;
    poo++;
    if (poo > 100) {
      poo = 0;
      test_bytes = 0;
      test_bits_compressed = 0;
    }
    return;
  }
  total_length += len;
  while (len > 0) {
    nodes[static_cast<uint8_t>(*buffer)].frequency++;
    total_count++;
    buffer++;
    len--;
  }
  if (total_length > kTrainingLength) {
    std::cout << "HUFFMAN TRAINING COMPLETE" << std::endl;

    build();

    // spit the C array to stdout for insertion into our code
    std::string s = "{";
    for (int i = 0; i < 256; i++) {
      s += std::to_string(nodes[i].frequency);
      if (i < 255) s += ",";
    }
    s += "}";
    std::cout << "FINAL: " << s << std::endl;
  }
}

void Huffman::build() {
  assert(!built);

  // if we're not in training mode, use our hard-coded values
  for (int i = 0; i < 256; i++) {
    nodes_[i].frequency = g_freqs[i];
  }

  // first 256 nodes are leaves
  int node_count = 256;

  // now loop through existing nodes finding the two smallest values without
  // parents and creating a new parent node for them with their sum as its
  // frequency value once there's only 1 node without a parent we're done
  // (that's the root node)
  int smallest1;
  int smallest2;
  while (node_count < 511) {
    int i = 0;

    // find first two non-parented nodes
    while (nodes_[i].parent != 0) i++;
    smallest1 = i;
    i++;
    while (nodes_[i].parent != 0) i++;
    smallest2 = i;
    i++;
    while (i < node_count) {
      if (nodes_[i].parent == 0) {
        // compare each node to the larger of the two existing to try and knock
        // it off
        if (nodes_[smallest1].frequency > nodes_[smallest2].frequency) {
          if (nodes_[i].frequency < nodes_[smallest1].frequency) smallest1 = i;
        } else {
          if (nodes_[i].frequency < nodes_[smallest2].frequency) smallest2 = i;
        }
      }
      i++;
    }
    nodes_[node_count].frequency =
      nodes_[smallest1].frequency + nodes_[smallest2].frequency;
    nodes_[smallest1].parent = static_cast<uint8_t>(node_count - 255);
    nodes_[smallest2].parent = static_cast<uint8_t>(node_count - 255);
    nodes_[node_count].right_child = static_cast<int16_t>(smallest1);
    nodes_[node_count].left_child = static_cast<int16_t>(smallest2);

    node_count++;
  }

  assert(nodes_[509].parent != 0);
  assert(nodes_[510].parent == 0);

  // now store binary values for each base value (0-255)
  for (int i = 0; i < 256; i++) {
    // uint32_t val = 0;
    nodes_[i].val = 0;
    nodes_[i].bits = 0;
    int index = i;
    while (nodes_[index].parent != 0) {
      // 0 if we're left child, 1 if we're right
      if (nodes_[nodes_[index].parent + 255].right_child == index) {
        nodes_[i].val = static_cast<uint16_t>(nodes_[i].val << 1 | 0x01);
      } else {
        assert(nodes_[nodes_[index].parent + 255].left_child == index);
        nodes_[i].val = nodes_[i].val << 1;
      }
      nodes_[i].bits++;

      index = nodes_[index].parent + 255;
    }
    // we're slightly different than normal huffman in that
    // our first bit denotes whether the following values are the huffman bits
    // or the full 8 bit value.
    if (nodes_[i].bits >= 8) {
      nodes_[i].bits = 8;
      // nodes[i].val = nodes[i].val << 1;
      nodes_[i].val = static_cast<uint16_t>(i << 1);
    } else {
      nodes_[i].val = static_cast<uint16_t>(
                        nodes_[i].val << 1
                        | 0x01);  // 1 in first bit denotes huffman compressed
    }
    // nodes[i].val = 0;
    nodes_[i].bits += 1;
  }

  built = true;
  // for (int x=0; x<256; x++) {
  //   std::cout << nodes_[x].val << ": " << nodes_[x].frequency << std::endl;
  // }
}
